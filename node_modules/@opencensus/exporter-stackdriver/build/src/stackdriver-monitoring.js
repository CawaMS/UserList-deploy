"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@opencensus/core");
const google_auth_library_1 = require("google-auth-library");
const googleapis_1 = require("googleapis");
const types_1 = require("./types");
googleapis_1.google.options({ headers: { 'x-opencensus-outgoing-request': 0x1 } });
const monitoring = googleapis_1.google.monitoring('v3');
/** Format and sends Stats to Stackdriver */
class StackdriverStatsExporter {
    constructor(options) {
        this.projectId = options.projectId;
        this.logger = options.logger || core_1.logger.logger();
    }
    /**
     * Is called whenever a view is registered.
     * @param view The registered view.
     */
    onRegisterView(view) {
        return this.authorize().then((authClient) => {
            const request = {
                name: `projects/${this.projectId}`,
                resource: this.createMetricDescriptorData(view),
                auth: authClient
            };
            return new Promise((resolve, reject) => {
                monitoring.projects.metricDescriptors.create(request, (err) => {
                    this.logger.debug('sent metric descriptor', request.resource);
                    err ? reject(err) : resolve();
                });
            });
        });
    }
    /**
     * Is called whenever a measure is recorded.
     * @param views The views associated with the measure
     * @param measurement The measurement recorded
     */
    onRecord(views, measurement) {
        const timeSeries = views.map(view => {
            return this.createTimeSeriesData(view, measurement);
        });
        return this.authorize().then(authClient => {
            const request = {
                name: `projects/${this.projectId}`,
                resource: { timeSeries },
                auth: authClient
            };
            return new Promise((resolve, reject) => {
                monitoring.projects.timeSeries.create(request, (err) => {
                    this.logger.debug('sent time series', request.resource.timeSeries);
                    err ? reject(err) : resolve();
                });
            });
        });
    }
    /**
     * Gets the Google Application Credentials from the environment variables
     * and authenticates the client.
     */
    authorize() {
        return google_auth_library_1.auth.getApplicationDefault()
            .then((client) => {
            let authClient = client.credential;
            if (authClient.createScopedRequired &&
                authClient.createScopedRequired()) {
                const scopes = ['https://www.googleapis.com/auth/cloud-platform'];
                authClient = authClient.createScoped(scopes);
            }
            return authClient;
        })
            .catch((err) => {
            err.message = `authorize error: ${err.message}`;
            throw (err);
        });
    }
    /**
     * Creates a Stackdriver TimeSeries from a given view and metric value.
     * @param view The view to get TimeSeries information from
     * @param measurement The measurement to get TimeSeries information from
     */
    createTimeSeriesData(view, measurement) {
        const aggregationData = view.getSnapshot(measurement.tags);
        const resourceLabels = { project_id: this.projectId };
        // For non Sum Aggregations, the end time should be the same as the start
        // time.
        const endTime = (new Date(aggregationData.timestamp)).toISOString();
        const startTime = view.aggregation === 1 /* SUM */ ?
            (new Date(view.startTime)).toISOString() :
            endTime;
        let value;
        if (view.measure.type === "INT64" /* INT64 */) {
            value = { int64Value: measurement.value.toString() };
        }
        else if (aggregationData.type === 3 /* DISTRIBUTION */) {
            value = { distributionValue: this.createDistribution(aggregationData) };
        }
        else {
            value = { doubleValue: measurement.value };
        }
        return {
            metric: {
                type: `custom.googleapis.com/${view.name}`,
                labels: measurement.tags
            },
            resource: { type: 'global', labels: resourceLabels },
            metricKind: this.createMetricKind(view.aggregation),
            valueType: this.createValueType(view),
            points: [{ interval: { startTime, endTime }, value }]
        };
    }
    /**
     * Formats an OpenCensus Distribution to Stackdriver's format.
     * @param distribution The OpenCensus Distribution Data
     */
    createDistribution(distribution) {
        return {
            count: distribution.count.toString(),
            mean: distribution.mean,
            sumOfSquaredDeviation: distribution.sumSquaredDeviations,
            range: { min: distribution.min, max: distribution.max },
            bucketOptions: {
                explicitBuckets: { bounds: this.getBucketBoundaries(distribution.buckets) }
            },
            bucketCounts: this.getBucketCounts(distribution.buckets)
        };
    }
    /**
     * Gets the bucket boundaries in an monotonicaly increasing order.
     * @param buckets The bucket list to get the boundaries from
     */
    getBucketBoundaries(buckets) {
        return [...buckets.map(bucket => bucket.lowBoundary), Infinity];
    }
    /**
     * Gets the count value for each bucket
     * @param buckets The bucket list to get the count values from
     */
    getBucketCounts(buckets) {
        return buckets.map(bucket => bucket.count);
    }
    /**
     * Creates a Stackdriver LabelDescriptor from given Tags.
     * @param tag The Tags to get TimeSeries information from.
     */
    createLabelDescriptor(tags) {
        return tags.map(labelKey => {
            return { key: labelKey, valueType: 'STRING', description: '' };
        });
    }
    /**
     * Creates a Stackdriver MetricDescriptor from a given view.
     * @param view The view to get MetricDescriptor information from
     */
    createMetricDescriptorData(view) {
        return {
            type: `custom.googleapis.com/${view.name}`,
            description: view.description || view.measure.description,
            displayName: view.measure.name,
            metricKind: this.createMetricKind(view.aggregation),
            valueType: this.createValueType(view),
            unit: view.measure.unit,
            labels: this.createLabelDescriptor(view.getColumns())
        };
    }
    /**
     * Creates a Stackdriver ValueType from a given view.
     * @param view The view to extract data from
     */
    createValueType(view) {
        if (view.measure.type === "INT64" /* INT64 */) {
            return types_1.ValueType.INT64;
        }
        else if (view.aggregation === 3 /* DISTRIBUTION */) {
            return types_1.ValueType.DISTRIBUTION;
        }
        return types_1.ValueType.DOUBLE;
    }
    /**
     * Creates a Stackdriver MetricKind from a given aggregation.
     * @param aggregationType The aggregation type to get MetricKind information
     * from.
     */
    createMetricKind(aggregationType) {
        if (aggregationType === 1 /* SUM */) {
            return types_1.MetricKind.CUMULATIVE;
        }
        return types_1.MetricKind.GAUGE;
    }
}
exports.StackdriverStatsExporter = StackdriverStatsExporter;
//# sourceMappingURL=stackdriver-monitoring.js.map