"use strict";
/**
 * Copyright 2018, OpenCensus Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
class Recorder {
    static addMeasurement(aggregationData, measurement) {
        aggregationData.timestamp = Date.now();
        const value = measurement.measure.type === "DOUBLE" /* DOUBLE */ ?
            measurement.value :
            Math.trunc(measurement.value);
        switch (aggregationData.type) {
            case 3 /* DISTRIBUTION */:
                return this.addToDistribution(aggregationData, value);
            case 1 /* SUM */:
                return this.addToSum(aggregationData, value);
            case 0 /* COUNT */:
                return this.addToCount(aggregationData, value);
            default:
                return this.addToLastValue(aggregationData, value);
        }
    }
    static addToDistribution(distributionData, value) {
        distributionData.count += 1;
        const inletBucket = distributionData.buckets.find((bucket) => {
            return bucket.lowBoundary <= value && value < bucket.highBoundary;
        });
        inletBucket.count += 1;
        if (value > distributionData.max) {
            distributionData.max = value;
        }
        if (value < distributionData.min) {
            distributionData.min = value;
        }
        if (distributionData.count === 1) {
            distributionData.mean = value;
        }
        distributionData.sum += value;
        const oldMean = distributionData.mean;
        distributionData.mean = distributionData.mean +
            (value - distributionData.mean) / distributionData.count;
        distributionData.sumSquaredDeviations =
            distributionData.sumSquaredDeviations +
                (value - oldMean) * (value - distributionData.mean);
        distributionData.stdDeviation = Math.sqrt(distributionData.sumSquaredDeviations / distributionData.count);
        return distributionData;
    }
    static addToSum(sumData, value) {
        sumData.value += value;
        return sumData;
    }
    static addToCount(countData, value) {
        countData.value += 1;
        return countData;
    }
    static addToLastValue(lastValueData, value) {
        lastValueData.value = value;
        return lastValueData;
    }
}
exports.Recorder = Recorder;
//# sourceMappingURL=recorder.js.map